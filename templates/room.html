{% extends "dashboard.html" %}

{% block content %}

<div class="card row" style="justify-content:space-between; align-items:center;">
  <div>
    <h2 id="gname" style="margin:0;">Group</h2>
    <div id="members" class="muted"></div>
    <div id="online_list" class="muted" style="margin-top:4px; font-size:0.9rem;">Online: -</div>
  </div>
  <div>
    <a class="btn" href="{{ url_for('room_home') }}">Back</a>
    <button class="btn danger" onclick="leaveGroup()" style="margin-left:6px;">Leave group</button>
  </div>
</div>

<div class="card">
  <div id="msgs" class="messages"></div>
  
  <!-- Typing indicator -->
  <div id="typing_indicator" style="display:none; padding:8px 12px; font-size:12px; color:#999; font-style:italic;">
    <span id="typing_user"></span> is typing...
  </div>

  <div class="row input-row" style="margin-top:12px; position:relative;">
    <input id="msg" class="input" placeholder="Type a message....."
           onkeydown="if(event.key==='Enter')sendMessage()" oninput="notifyTyping()"/>
    <input id="file_input" type="file" style="display:none" onchange="uploadGroupFile(event)">
    <button class="btn" onclick="toggleEmojiPicker('group_emoji_picker')">ğŸ˜€</button>
    <button class="btn" onclick="document.getElementById('file_input').click()">ğŸ“</button>
    <button class="btn" onclick="sendMessage()">Send</button>
    <!-- Emoji picker dropdown for group -->
    <div id="group_emoji_picker" style="display:none; position:absolute; bottom:50px; right:0; background:#fff; border:1px solid #ddd; border-radius:8px; padding:10px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:1000;">
      <div style="display:grid; grid-template-columns:repeat(6,1fr); gap:5px; width:200px;">
        <span onclick="insertEmoji('ğŸ˜€', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ˜€</span>
        <span onclick="insertEmoji('ğŸ˜‚', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ˜‚</span>
        <span onclick="insertEmoji('â¤ï¸', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">â¤ï¸</span>
        <span onclick="insertEmoji('ğŸ‘', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ‘</span>
        <span onclick="insertEmoji('ğŸ‰', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ‰</span>
        <span onclick="insertEmoji('ğŸ”¥', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ”¥</span>
        <span onclick="insertEmoji('ğŸ˜', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ˜</span>
        <span onclick="insertEmoji('ğŸ‘€', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ‘€</span>
        <span onclick="insertEmoji('ğŸ’¯', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ’¯</span>
        <span onclick="insertEmoji('ğŸ¤”', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ¤”</span>
        <span onclick="insertEmoji('ğŸ˜', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ˜</span>
        <span onclick="insertEmoji('ğŸ˜±', 'msg')" style="cursor:pointer; font-size:20px; text-align:center;">ğŸ˜±</span>
      </div>
    </div>
  </div>
</div>

<style>
.messages {
  height: 65vh;
  overflow:auto;
  background:#f7fafc;
  border-radius:12px;
  padding:16px;
  display:flex;
  flex-direction:column;
  gap:10px;
}

.msg-row {
  display:flex;
  margin:6px 0;
}

.input{
  padding:12px 14px;
  border:1.5px solid #e2e8f0;
  border-radius:12px;
  background:#f7fafc;
  width:75%;
}

.btn{
  padding:10px 16px;
  margin-left:8px;
  background:#667eea;
  color:#fff;
  border:none;
  border-radius:8px;
  cursor:pointer;
  transition:background 0.3s ease;
}
.btn:hover{
  background:#5a67d8;
}

.btn.danger{
  background:#dc2626;
}
.btn.danger:hover{
  background:#b91c1c;
}

/* bubble container */
.msg-bubble {
  display:inline-block;
  padding:10px 14px;
  border-radius:14px;
  max-width:75%;
  word-wrap:break-word;
  box-shadow:0 2px 8px rgba(0,0,0,.05);
  background:#ffffff;
  color:#222;
}

.msg-meta {
  font-size:12px;
  color:rgba(0,0,0,0.55);
  margin-bottom:6px;
}

.msg-content {
  white-space:pre-wrap;
}

/* actions (edit button) */
.msg-actions {
  margin-top:4px;
  text-align:right;
  font-size:11px;
}

.msg-edit-btn {
  border:none;
  background:transparent;
  cursor:pointer;
  text-decoration:underline;
  padding:0;
  font-size:11px;
  color:#e5e7eb;
}

.msg-row.me .msg-edit-btn {
  color:#e5e7eb;
}

.msg-row.other .msg-edit-btn {
  color:#4b5563;
}

/* system text */
.system {
  text-align:center;
  opacity:0.7;
  font-size:13px;
  color:#555;
}
</style>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
// Inject user_id from template
const _tempEl = document.createElement('div');
_tempEl.setAttribute('data-user-id', '{{ user_id|default("") }}');
let MY_USER_ID = null;
const rawId = _tempEl.getAttribute('data-user-id');
MY_USER_ID = rawId === undefined || rawId === '' ? null : (isNaN(rawId) ? rawId : Number(rawId));

const socket = io();

function escapeHtml(s){ const p=document.createElement('p'); p.appendChild(document.createTextNode(s||'')); return p.innerHTML; }
function qs(name){ return new URLSearchParams(location.search).get(name); }
function toLocal(ts){ const d = new Date((ts||'').replace(' ','T')); return isNaN(d)?'':d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }
function scrollBottom(){ const box=document.getElementById('msgs'); if(box) box.scrollTop = box.scrollHeight; }

const groupId = Number(qs('gid'));
if(!groupId){
  console.warn('Missing gid in URL (use /room?gid=123)');
}

let groupMembers = [];
let typingTimeout;

// SYSTEM MESSAGE
function appendSystem(text){
  const box = document.getElementById('msgs');
  if(!box) return;
  const row = document.createElement('div');
  row.className = 'system';
  row.textContent = text;
  box.appendChild(row);
  scrollBottom();
}

// build row DOM for a single message
function createMessageRow(m){
  const box = document.getElementById('msgs');
  const senderId = (typeof m.sender_id === 'number') ? m.sender_id : Number(m.sender_id);
  const me = (MY_USER_ID !== null && !Number.isNaN(senderId) && senderId === MY_USER_ID);

  const wrap = document.createElement('div');
  wrap.className = 'msg-row ' + (me ? 'me' : 'other');
  wrap.dataset.msgId = m.id;

  wrap.style.display = 'flex';
  wrap.style.justifyContent = me ? 'flex-end' : 'flex-start';

  const bubble = document.createElement('div');
  bubble.className = 'msg-bubble';
  bubble.style.lineHeight = '1.3';

  if (me) {
    bubble.style.background = 'linear-gradient(135deg,#667eea,#764ba2)';
    bubble.style.color = '#fff';
    bubble.style.borderBottomRightRadius = '4px';
  } else {
    bubble.style.background = '#f0f2f6';
    bubble.style.color = '#111';
    bubble.style.borderBottomLeftRadius = '4px';
  }

  const meta = document.createElement('div');
  meta.className = 'msg-meta';
  meta.textContent = `${me ? 'You' : (m.sender_name || 'Someone')} â€¢ ${toLocal(m.created_at)}`;

  const content = document.createElement('div');
  content.className = 'msg-content';
  content.innerHTML = escapeHtml(m.content || '');

  bubble.appendChild(meta);
  bubble.appendChild(content);

  // attachment
  if(m.file_path){
    const attachmentEl = (function(fp, isMe){
      if(!fp) return null;
      const parts = fp.split('/');
      const fname = parts[parts.length-1] || fp;
      const idx = fname.lastIndexOf('.');
      const ext = idx>-1 ? fname.slice(idx+1).toLowerCase() : '';
      const imgExt = ['png','jpg','jpeg','gif','webp','bmp'];
      const videoExt = ['mp4','webm','ogg'];
      const audioExt = ['mp3','wav','ogg'];

      if(imgExt.includes(ext)){
        const img = document.createElement('img');
        img.src = fp;
        img.style.display = 'block';
        img.style.maxWidth = '100%';
        img.style.borderRadius = '8px';
        img.style.marginTop = '8px';
        img.style.objectFit = 'cover';
        return img;
      }

      if(videoExt.includes(ext)){
        const v = document.createElement('video');
        v.src = fp;
        v.controls = true;
        v.style.display = 'block';
        v.style.maxWidth = '100%';
        v.style.borderRadius = '8px';
        v.style.marginTop = '8px';
        return v;
      }

      if(audioExt.includes(ext)){
        const a = document.createElement('audio');
        a.src = fp;
        a.controls = true;
        a.style.display = 'block';
        a.style.marginTop = '8px';
        return a;
      }

      const link = document.createElement('a');
      link.href = fp;
      link.target = '_blank';
      link.style.display = 'inline-block';
      link.style.marginTop = '8px';
      link.style.color = isMe ? '#fff' : '#667eea';
      link.style.textDecoration = 'none';
      link.textContent = 'ğŸ“ ' + fname;
      return link;
    })(m.file_path, me);
    if(attachmentEl) bubble.appendChild(attachmentEl);
  }

  // edit button for own messages
  if (me) {
    const actions = document.createElement('div');
    actions.className = 'msg-actions';
    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'msg-edit-btn';
    editBtn.textContent = 'Edit';
    editBtn.onclick = () => {
      const currentText = m.content || '';
      const newText = prompt('Edit your message:', currentText);
      if (newText === null) return;
      const trimmed = newText.trim();
      if (!trimmed) return;
      socket.emit('edit_group_message', {
        group_id: groupId,
        message_id: m.id,
        content: trimmed
      });
    };
    actions.appendChild(editBtn);
    bubble.appendChild(actions);
  }

  wrap.appendChild(bubble);
  return wrap;
}

// append message (for initial load + new messages)
function appendMessage(m){
  const box = document.getElementById('msgs');
  if(!box) return;
  const row = createMessageRow(m);
  box.appendChild(row);
  scrollBottom();
}

// refresh "who is online" in this group
async function refreshOnlineMembers(){
  if(!groupId) return;
  const el = document.getElementById('online_list');
  if(!el) return;
  try{
    const res = await fetch(`/api/groups/${groupId}/online`);
    const data = await res.json();
    if(data.error){
      el.textContent = 'Online: -';
      return;
    }
    const online = data.online || [];
    if(online.length === 0){
      el.textContent = 'Online: none';
      return;
    }
    const names = online.map(u => u.username);
    el.textContent = 'Online: ' + names.join(', ');
  }catch(e){
    console.error('Failed to load online members', e);
    el.textContent = 'Online: -';
  }
}

// SOCKET + INITIAL LOAD
socket.on('connect', async () => {
  if(!groupId) return;
  try {
    const r = await fetch(`/api/groups/${groupId}`);
    const data = await r.json();
    if(data.error){ appendSystem(data.error); return; }

    document.getElementById('gname').textContent = data.group.name;
    groupMembers = data.members || [];
    document.getElementById('members').textContent = groupMembers.map(m=>m.username).join(', ');

    (data.messages || []).forEach(appendMessage);

    socket.emit('join_group', { group_id: groupId });
    socket.emit('mark_read', { group_id: groupId });

    // first presence load
    refreshOnlineMembers();
    // poll every 10 seconds
    setInterval(refreshOnlineMembers, 10000);
  } catch(err){
    console.error('Failed to load group:', err);
    appendSystem('Failed to load messages');
  }
});

socket.on('new_message', (msg) => {
  appendMessage(msg);
  socket.emit('mark_read', { group_id: groupId });
});

socket.on('group_message_edited', (msg) => {
  const box = document.getElementById('msgs');
  if(!box) return;
  const rows = box.querySelectorAll('.msg-row');
  rows.forEach(row => {
    if(Number(row.dataset.msgId) === msg.id){
      const newRow = createMessageRow(msg);
      box.replaceChild(newRow, row);
    }
  });
});

socket.on('system', (data) => appendSystem(data.message));

// SEND MESSAGE
function sendMessage(){
  const input = document.getElementById('msg');
  if(!input) return;
  const content = (input.value || '').trim();
  if(!content) return;
  socket.emit('send_message', { group_id: groupId, content });
  input.value = '';
  const picker = document.getElementById('group_emoji_picker');
  if(picker) picker.style.display = 'none';
}

// FILE UPLOAD
async function uploadGroupFile(e){
  const f = e.target.files[0];
  if(!f) return;
  const fd = new FormData();
  fd.append('file', f);
  fd.append('group_id', groupId);
  try{
    const res = await fetch('/api/group/upload', { method:'POST', body: fd });
    const data = await res.json();
    if(data && data.ok){
      socket.emit('send_message', { group_id: groupId, content: `Shared file: ${f.name}`, file_path: data.file_path });
    } else {
      alert('Upload failed: ' + (data.error || 'Unknown error'));
    }
  } catch(err){
    alert('Upload error: ' + err.message);
  }
  e.target.value = '';
}

// LEAVE GROUP
async function leaveGroup(){
  if(!groupId) return;
  if(!confirm('Leave this group? You will stop receiving messages from it.')) return;
  try{
    const res = await fetch(`/api/groups/${groupId}/leave`, { method:'POST' });
    const data = await res.json();
    if(data.ok){
      socket.emit('leave_group', { group_id: groupId });
      window.location = "{{ url_for('room_home') }}";
    }else{
      alert('Could not leave group: ' + (data.error || 'Unknown error'));
    }
  }catch(e){
    alert('Error leaving group: ' + e.message);
  }
}

// EMOJI
function toggleEmojiPicker(pickerId){
  const picker = document.getElementById(pickerId);
  picker.style.display = picker.style.display === 'none' ? 'block' : 'none';
}

function insertEmoji(emoji, inputId){
  const input = document.getElementById(inputId);
  input.value += emoji;
  input.focus();
  const pickers = document.querySelectorAll('[id$="_emoji_picker"]');
  pickers.forEach(p => p.style.display = 'none');
}

// TYPING INDICATOR
function notifyTyping(){
  socket.emit('typing', { group_id: groupId });
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    socket.emit('stop_typing', { group_id: groupId });
  }, 1000);
}

socket.on('user_typing', (data) => {
  const indicator = document.getElementById('typing_indicator');
  const typingUser = document.getElementById('typing_user');
  if(indicator && typingUser){
    typingUser.textContent = data.username || 'Someone';
    indicator.style.display = 'block';
  }
});

socket.on('user_stop_typing', () => {
  const indicator = document.getElementById('typing_indicator');
  if(indicator) indicator.style.display = 'none';
});
</script>

{% endblock %}
